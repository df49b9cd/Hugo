# Hugo TaskQueue Control Plane Stories

This document breaks down three Hugo work items that emerged while examining how OmniRelay layers SafeTaskQueue-backed resource leasing, replication, and throttling in production (`src/OmniRelay/Dispatcher/ResourceLeaseDispatcher.cs:11-223`, `docs/reference/distributed-task-leasing.md:1-78`). Each story is structured with the artifacts engineering and QA teams need to plan, implement, and verify the enhancements before OmniRelay migrates from its bespoke dispatcher utilities.

## Story 1 – TaskQueue Backpressure Monitor & Limiter Integration

### Goal
- Provide a reusable `TaskQueueBackpressureMonitor` inside Hugo so hosts can observe SafeTaskQueue depth, toggle throttling, and publish state changes without duplicating OmniRelay’s `ResourceLeaseBackpressureSignal` + rate-limiter selector (`src/OmniRelay/Dispatcher/ResourceLeaseBackpressure.cs:4-26`, `src/OmniRelay/Dispatcher/ResourceLeaseBackpressureListeners.cs:8-150`).

### Scope
- Applies to Hugo’s TaskQueue package and the `Go` concurrency toolkit.
- Covers synchronous/asynchronous waiters, backpressure cooldown enforcement, and rate-limiter selection hooks.
- Excludes transport- or tenant-specific admission control; callers still choose how to act on signals.

### Requirements
1. Surface a `TaskQueueBackpressureMonitor` type that wraps a `SafeTaskQueue<T>` (or `TaskQueue<T>`) and tracks pending count against configurable high/low watermarks plus optional cooldown (parity with `ResourceLeaseDispatcherComponent` in `src/OmniRelay/Dispatcher/ResourceLeaseDispatcher.cs:490-520`).
2. Emit strongly typed `TaskQueueBackpressureSignal` instances with timestamp, pending count, high/low watermark metadata, and monotonic transitions (mirroring OmniRelay’s signal contract).
3. Provide an `ITaskQueueBackpressureListener` interface + default implementations:
   - `BackpressureAwareRateLimiter` analog that swaps between two `RateLimiter` instances and exposes a `LimiterSelector` delegate for OmniRelay’s middleware (`src/OmniRelay/Dispatcher/ResourceLeaseBackpressureListeners.cs:8-80`).
   - `TaskQueueBackpressureDiagnosticsListener` analog with `ChannelReader<TaskQueueBackpressureSignal>` + latest snapshot for control-plane endpoints.
4. Expose a `WaitForDrainingAsync` helper (same semantics as `WaitForBackpressureAsync` in `src/OmniRelay/Dispatcher/ResourceLeaseDispatcher.cs:500-512`) so enqueue paths can await signal clearance without rewriting loops.
5. Ensure monitor instances integrate with `GoDiagnostics` to record transitions, durations, and queue depth gauges, feeding OmniRelay dashboards currently built on `ResourceLeaseMetrics` (`docs/reference/distributed-task-leasing.md:60-78`).

### Deliverables
- New Hugo namespace (e.g., `Hugo.TaskQueues.Backpressure`) with `TaskQueueBackpressureMonitor`, `TaskQueueBackpressureSignal`, listener interfaces, limiter selector, and diagnostics listener implementations.
- XML docs and `docs/reference/hugo-api-reference.md` updates describing the APIs and configuration knobs.
- Sample wiring guide demonstrating OmniRelay dispatcher migration (codesnippet referencing RateLimiting middleware).
- Unit, integration, and feature tests (detailed below).

### Acceptance Criteria
1. Monitor accurately toggles state when queue pending count crosses thresholds and respects cooldown windows during churn (verified via automated tests).
2. Consuming middleware can plug `LimiterSelector` and observe throttling adjustments identical to OmniRelay’s current listener (prove via integration harness).
3. Diagnostics listener exposes latest signal + historical channel for HTTP/gRPC streaming endpoints without dropping events under load.
4. `GoDiagnostics` meters produce `hugo.taskqueue.backpressure.active`, `pending`, and `transitions` instruments with metadata ready for OmniRelay dashboards.
5. Migration spike demonstrates OmniRelay dispatcher can delete `ResourceLeaseBackpressure*` files in favor of the Hugo primitives without functionality loss (tracked in rollout notes, not necessarily merged).

### References
- `docs/reference/distributed-task-leasing.md:60-78` – current OmniRelay guidance for listener registration + metrics.
- `src/OmniRelay/Dispatcher/ResourceLeaseDispatcher.cs:490-520` – manual gate + wait logic.
- `src/OmniRelay/Dispatcher/ResourceLeaseBackpressure.cs:4-26` – signal contract to mirror.
- `src/OmniRelay/Dispatcher/ResourceLeaseBackpressureListeners.cs:8-150` – rate limiter selector + diagnostics listener behaviour.

### Testing Strategy
- Combine deterministic unit tests (monitor math, cooldowns) with TaskQueue integration harness tests (simulate enqueue/lease operations) and feature tests that drive OmniRelay middleware against the library to validate end-to-end throttling.
- Stress-test channels and limiter hot swapping under concurrent producers/consumers to ensure no deadlocks or missed transitions.
- Automation should run under both `TaskQueue<T>` and `SafeTaskQueue<T>` to guarantee compatibility.

### Unit Test Scenarios
- Trigger transitions by enqueuing items past the high watermark and draining below the low watermark; assert state flips and timestamps.
- Validate cooldown enforcement by rapidly oscillating around thresholds; ensure redundant notifications are suppressed until cooldown elapses.
- Confirm `WaitForDrainingAsync` unblocks when `_isBackpressureActive` flips and cancels when the provided `CancellationToken` fires.
- Verify `TaskQueueBackpressureDiagnosticsListener` ring buffer capacity enforcement and snapshot updates.

### Integration Test Scenarios
- Spin up a `SafeTaskQueue<T>` with the monitor and run concurrent producers/consumers; assert limiter selector returns backpressure limiter only while pending count stays above threshold.
- Attach diagnostics listener to a Kestrel endpoint (similar to `ResourceLeaseBackpressureDiagnosticsListener` usage in `samples/ResourceLease.MeshDemo/Program.cs:63-137`) and stream events; verify ordering + delivery.
- Plug the monitor into OmniRelay’s `RateLimitingMiddleware` via the new selector and ensure RPC throughput throttles when queue is stressed, matching legacy listener behaviour.

### Feature Test Scenarios
- Deploy OmniRelay sample mesh with the Hugo monitor and collect metrics via `GoDiagnostics`; validate dashboards show the same fields as the bespoke instrumentation.
- Run chaos workload that spikes backlog, recovers, and spikes again; confirm auto-scaling automation can observe transitions via the diagnostics endpoint without gaps.
- Include canary toggles to switch between old/new monitors and compare latency/throughput/CPU to ensure no regressions.
